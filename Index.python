import tensorflow as tf
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv2D, UpSampling2D

def super_resolution_model():
    input_img = Input(shape=(None, None, 3)) # Replace with your input shape

    # Simple CNN architecture for super-resolution
    x = Conv2D(64, (3, 3), activation='relu', padding='same')(input_img)
    x = UpSampling2D((2, 2))(x) # Upsampling by a factor of 2
    x = Conv2D(3, (3, 3), activation='sigmoid', padding='same')(x)

    model = Model(input_img, x)
    model.compile(optimizer='adam', loss='mean_squared_error')

    return model

# Instantiate and train the model with your data
sr_model = super_resolution_model()
# sr_model.fit(...)
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, UpSampling2D

def enhance_property_images(input_shape=(None, None, 3)):
    # Define a simple CNN architecture for image enhancement
    model = Sequential()
    model.add(Conv2D(64, (3, 3), activation='relu', padding='same', input_shape=input_shape))
    model.add(UpSampling2D((2, 2))) # Upsampling by a factor of 2
    model.add(Conv2D(3, (3, 3), activation='sigmoid', padding='same'))

    # Compile the model with an appropriate optimizer and loss function
    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

# Instantiate the model
enhancement_model = enhance_property_images()

# Train the model with your dataset of property images
# enhancement_model.fit(...)
import tensorflow as tf
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Conv2D, UpSampling2D, Input, Layer
from tensorflow.keras.layers import Reshape, Flatten, Dense
from tensorflow_io.experimental.color import rgb_to_grayscale

# Define a simple CNN architecture for image enhancement
def enhance_property_images(input_shape=(None, None, 3)):
    input_img = Input(shape=input_shape)

    # Encoder
    x = Conv2D(64, (3, 3), activation='relu', padding='same')(input_img)
    x = Conv2D(64, (3, 3), activation='relu', padding='same')(x)
    x = Flatten()(x)
    encoded = Dense(64, activation='relu')(x)

    # Decoder
    x = Dense(tf.reduce_prod(input_shape), activation='relu')(encoded)
    x = Reshape(input_shape)(x)
    x = Conv2D(64, (3, 3), activation='relu', padding='same')(x)
    x = UpSampling2D((2, 2))(x) # Upsampling by a factor of 2
    decoded = Conv2D(3, (3, 3), activation='sigmoid', padding='same')(x)

    # Autoencoder
    autoencoder = Model(input_img, decoded)
    autoencoder.compile(optimizer='adam', loss='mean_squared_error')

    return autoencoder

# Instantiate the model
enhancement_model = enhance_property_images()

# Function to adjust brightness and contrast
def adjust_brightness_contrast(image, brightness_delta, contrast_factor):
    # Adjust brightness
    adjusted = tf.image.adjust_brightness(image, brightness_delta)

    # Adjust contrast
    adjusted = tf.image.adjust_contrast(adjusted, contrast_factor)

    return adjusted

# Function to convert RGB to grayscale
def convert_to_grayscale(image):
    grayscale = rgb_to_grayscale(image)
    return grayscale

# Example usage:
# image = ... # Load your image tensor here
# enhanced_image = enhancement_model(image)
# bright_contrast_image = adjust_brightness_contrast(enhanced_image, 0.1, 2)
# grayscale_image = convert_to_grayscale(bright_contrast_image)

import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, UpSampling2D
from tensorflow.keras.models import Model

# Define the encoder
input_img = Input(shape=(256, 256, 3)) # Adjust the shape to match your dataset
x = Conv2D(32, (3, 3), activation='relu', padding='same')(input_img)
x = MaxPooling2D((2, 2), padding='same')(x)
encoded = Conv2D(16, (3, 3), activation='relu', padding='same')(x)

# Define the decoder
x = Conv2D(16, (3, 3), activation='relu', padding='same')(encoded)
x = UpSampling2D((2, 2))(x)
decoded = Conv2D(3, (3, 3), activation='sigmoid', padding='same')(x)

# Define the autoencoder
autoencoder = Model(input_img, decoded)
autoencoder.compile(optimizer='adam', loss='mean_squared_error')

# Train the autoencoder
# autoencoder.fit(noisy_images, clean_images, epochs=50, batch_size=128, validation_split=0.2)

import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, UpSampling2D
from tensorflow.keras.models import Model
import tensorflow_io as tfio

# Define the encoder for the autoencoder
input_img = Input(shape=(256, 256, 3)) # Adjust the shape to match your dataset
x = Conv2D(32, (3, 3), activation='relu', padding='same')(input_img)
x = MaxPooling2D((2, 2), padding='same')(x)
encoded = Conv2D(16, (3, 3), activation='relu', padding='same')(x)

# Define the decoder for the autoencoder
x = Conv2D(16, (3, 3), activation='relu', padding='same')(encoded)
x = UpSampling2D((2, 2))(x)
decoded = Conv2D(3, (3, 3), activation='sigmoid', padding='same')(x)

# Define the autoencoder
autoencoder = Model(input_img, decoded)
autoencoder.compile(optimizer='adam', loss='mean_squared_error')

# Function to perform color correction
def color_correction(image):
    # Convert RGB to YCbCr color space
    ycbcr = tfio.experimental.color.rgb_to_ycbcr(tf.cast(image, tf.float32) / 255.0)
    # Perform color correction operations on the YCbCr image
    # ...
    return ycbcr

# Function to apply style transfer
def apply_style_transfer(content_image, style_image):
    # Load pre-trained style transfer model and apply style transfer
    # ...
    return styled_image

# Example usage:
# Train the autoencoder with noisy and clean images
# autoencoder.fit(noisy_images, clean_images, epochs=50, batch_size=128, validation_split=0.2)

# Perform color correction on an image
# corrected_image = color_correction(input_image)

# Apply style transfer to an image
# styled_image = apply_style_transfer(content_image, style_image)

import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, UpSampling2D
from tensorflow.keras.models import Model

# Define the encoder
input_img = Input(shape=(256, 256, 3)) # Adjust the shape to match your dataset
x = Conv2D(32, (3, 3), activation='relu', padding='same')(input_img)
x = MaxPooling2D((2, 2), padding='same')(x)
encoded = Conv2D(16, (3, 3), activation='relu', padding='same')(x)

# Define the decoder
x = Conv2D(16, (3, 3), activation='relu', padding='same')(encoded)
x = UpSampling2D((2, 2))(x)
decoded = Conv2D(3, (3, 3), activation='sigmoid', padding='same')(x)

# Define the autoencoder
autoencoder = Model(input_img, decoded)
autoencoder.compile(optimizer='adam', loss='mean_squared_error')

# Train the autoencoder
# autoencoder.fit(noisy_images, clean_images, epochs=50, batch_size=128, validation_split=0.2)

import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, UpSampling2D, Conv2DTranspose
from tensorflow.keras.models import Model
import tensorflow_io as tfio
import numpy as np

# Define the autoencoder architecture
def build_autoencoder(input_shape):
    input_img = Input(shape=input_shape)
    # Encoder
    x = Conv2D(32, (3, 3), activation='relu', padding='same')(input_img)
    x = MaxPooling2D((2, 2), padding='same')(x)
    # Decoder
    x = Conv2DTranspose(32, (3, 3), strides=2, activation='relu', padding='same')(x)
    decoded = Conv2D(3, (3, 3), activation='sigmoid', padding='same')(x)
    # Autoencoder
    autoencoder = Model(input_img, decoded)
    autoencoder.compile(optimizer='adam', loss='mean_squared_error')
    return autoencoder

# Function to add noise to images
def add_noise(images, noise_factor=0.5):
    noisy_images = images + noise_factor * np.random.normal(loc=0.0, scale=1.0, size=images.shape)
    noisy_images = np.clip(noisy_images, 0., 1.)
    return noisy_images

# Function for color correction using TensorFlow I/O
def color_correction(image):
    # Convert RGB to YCbCr color space
    ycbcr = tfio.experimental.color.rgb_to_ycbcr(tf.cast(image, tf.float32) / 255.0)
    # Perform color correction operations on the YCbCr image
    # ...
    return ycbcr

# Placeholder function for style transfer
def style_transfer(content_image, style_image):
    # Load pre-trained style transfer model and apply style transfer
    # ...
    return styled_image

# Example usage:
# Load your dataset of clean images
clean_images = # ... load clean images
# Create noisy images
noisy_images = add_noise(clean_images)

# Build and train the autoencoder
autoencoder = build_autoencoder(clean_images[0].shape)
autoencoder.fit(noisy_images, clean_images, epochs=50, batch_size=128, validation_split=0.2)

# Apply color correction to an image
corrected_image = color_correction(clean_images[0])

# Apply style transfer to an image (assuming you have a style image)
styled_image = style_transfer(clean_images[0], style_image) # style_image needs to be defined
# Import necessary libraries
from keras.models import load_model
from PIL import Image
import numpy as np
import io

# Load pre-trained models (paths to models need to be specified)
super_resolution_model = load_model('path_to_super_resolution_model.h5')
image_enhancement_model = load_model('path_to_image_enhancement_model.h5')
autoencoder_model = load_model('path_to_autoencoder_model.h5')

# Define a function to enhance property images
def enhance_property_images(image_path):
    # Load the image
    original_image = Image.open(image_path)
    
    # Preprocess the image for super-resolution model
    sr_preprocessed_image = preprocess_for_super_resolution(original_image)
    
    # Enhance image resolution
    enhanced_resolution_image = super_resolution_model.predict(sr_preprocessed_image)
    
    # Preprocess the image for image enhancement model
    ie_preprocessed_image = preprocess_for_image_enhancement(enhanced_resolution_image)
    
    # Enhance image quality
    enhanced_quality_image = image_enhancement_model.predict(ie_preprocessed_image)
    
    # Preprocess the image for autoencoder model
    ae_preprocessed_image = preprocess_for_autoencoder(enhanced_quality_image)
    
    # Denoise and reconstruct the image
    final_enhanced_image = autoencoder_model.predict(ae_preprocessed_image)
    
    # Post-process the image to convert it back to a suitable format
    final_image = postprocess_image(final_enhanced_image)
    
    # Save or return the enhanced image
    final_image.save('enhanced_image.png')
    return io.BytesIO(final_image.tobytes()), 'image/png'

# Define helper functions for preprocessing and postprocessing
def preprocess_for_super_resolution(image):
    # Implement preprocessing steps for super-resolution model
    pass

def preprocess_for_image_enhancement(image):
    # Implement preprocessing steps for image enhancement model
    pass

def preprocess_for_autoencoder(image):
    # Implement preprocessing steps for autoencoder model
    pass

def postprocess_image(image):
    # Implement postprocessing steps to convert the model output to image format
    pass

# Integrate the enhancement function into the application's image upload pipeline
@app.route('/upload', methods=['POST'])
def upload_image():
    if 'file' not in request.files:
        return 'No file part', 400
    file = request.files['file']
    if file.filename == '':
        return 'No selected file', 400
    if file and allowed_file(file.filename):
        # Call the enhancement function
        enhanced_image, image_format = enhance_property_images(file)
        # Further code to handle the enhanced image (e.g., save to database, return to user)
        pass

# Define additional routes and functionalities as needed

//Import necessary libraries
import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, UpSampling2D, BatchNormalization
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
import tensorflow_datasets as tfds
import tensorflow_io as tfio
# app.py (Flask example)

from flask import Flask, request, jsonify
import stripe

app = Flask(__name__)

# Initialize Stripe with your API key (replace with your actual secret key)
stripe.api_key = "your_stripe_secret_key"

# Example route for creating a payment intent
@app.route("/create-payment-intent", methods=["POST"])
def create_payment_intent():
    try:
        # Get the amount from the request (you can adjust this based on your needs)
        amount = request.json.get("amount")

        # Create a payment intent
        intent = stripe.PaymentIntent.create(
            amount=amount,
            currency="usd",  # Replace with your preferred currency
            payment_method_types=["card"],
            description="Booking payment",
            confirm=True,
        )

        # Return the client secret to the frontend
        return jsonify({"clientSecret": intent.client_secret})

    except Exception as e:
        return jsonify({"error": str(e)}), 500

# Example route for handling payment callbacks (webhooks)
@app.route("/webhook", methods=["POST"])
def handle_webhook():
    payload = request.data
    try:
        # Verify the webhook event (using your endpoint secret)
        event = stripe.Webhook.construct_event(
            payload, sig_header=request.headers.get("Stripe-Signature"), secret="your_webhook_secret"
        )

        # Handle specific events (e.g., payment succeeded, refund issued)
        if event.type == "payment_intent.succeeded":
            # Update booking status (e.g., mark as paid)
            # Handle other relevant actions

        return jsonify({"status": "success"})

    except Exception as e:
        return jsonify({"error": str(e)}), 400

if __name__ == "__main__":
    app.run(debug=True)
# app.py (Flask example)

from flask import Flask, request, jsonify
import stripe

app = Flask(__name__)

# Initialize Stripe with your API key (replace with your actual secret key)
stripe.api_key = "your_stripe_secret_key"

# Example route for creating an escrow payment intent
@app.route("/create-escrow-payment", methods=["POST"])
def create_escrow_payment():
    try:
        # Get the amount and booking ID from the request
        amount = request.json.get("amount")
        booking_id = request.json.get("booking_id")

        # Create a payment intent with escrow setup
        intent = stripe.PaymentIntent.create(
            amount=amount,
            currency="usd",  # Replace with your preferred currency
            payment_method_types=["card"],
            description=f"Booking payment for Booking ID {booking_id}",
            setup_future_usage="off_session",  # Set up for future payments
            application_fee_amount=100,  # Example fee (adjust as needed)
            transfer_data={
                "destination": "host_stripe_account_id",  # Host's Stripe account ID
            },
        )

        # Return the client secret to the frontend
        return jsonify({"clientSecret": intent.client_secret})

    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    app.run(debug=True)
# app.py

from flask import Flask, request, jsonify
import sqlite3

app = Flask(__name__)
db_path = "booking_system.db"

# Initialize database (create tables if not exists)
def init_db():
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            name TEXT,
            email TEXT UNIQUE
        );
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS rooms (
            room_id INTEGER PRIMARY KEY,
            room_type TEXT,
            capacity INTEGER,
            price REAL
        );
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS bookings (
            booking_id INTEGER PRIMARY KEY,
            user_id INTEGER,
            room_id INTEGER,
            check_in_date DATE,
            check_out_date DATE,
            payment_status TEXT,
            FOREIGN KEY (user_id) REFERENCES users(user_id),
            FOREIGN KEY (room_id) REFERENCES rooms(room_id)
        );
    """)
    conn.commit()
    conn.close()

@app.route("/create-booking", methods=["POST"])
def create_booking():
    # Validate input and insert into bookings table
    # Update room availability
    # Return success message or error
    # ...

@app.route("/update-booking/<int:booking_id>", methods=["PUT"])
def update_booking(booking_id):
    # Validate input and update booking details
    # Return success message or error
    # ...

@app.route("/get-bookings/<int:user_id>", methods=["GET"])
def get_bookings(user_id):
    # Fetch bookings for the given user
    # Return booking details
    # ...

# Other routes for payment status update, etc.

if __name__ == "__main__":
    init_db()
    app.run(debug=True)
pip install Flask-Mail
# config.py
MAIL_SERVER = 'smtp.example.com'
MAIL_PORT = 587
MAIL_USE_TLS = True
MAIL_USERNAME = 'your_email@example.com'
MAIL_PASSWORD = 'your_email_password'
MAIL_DEFAULT_SENDER = 'your_email@example.com'
from flask import Flask
from flask_mail import Mail

app = Flask(__name__)
app.config.from_object('config')  # Load email configuration
mail = Mail(app)
from flask_mail import Message

def send_booking_confirmation_email(user_email, booking_details):
    msg = Message('Booking Confirmation', recipients=[user_email])
    msg.html = render_template('emails/booking_confirmation.html', booking=booking_details)
    mail.send(msg)

def send_payment_update_email(user_email, payment_status):
    msg = Message('Payment Update', recipients=[user_email])
    msg.html = render_template('emails/payment_update.html', status=payment_status)
    mail.send(msg)
@app.route('/booking-confirmed/<booking_id>')
def booking_confirmed(booking_id):
    # Fetch booking details
    # Send confirmation email
    send_booking_confirmation_email(user_email, booking_details)
    # Other logic

@app.route('/payment-updated/<payment_status>')
def payment_updated(payment_status):
    # Fetch user email
    # Send payment update email
    send_payment_update_email(user_email, payment_status)
    # Other logic
from flask import Flask, request, jsonify
import pandas as pd
from sklearn.neighbors import NearestNeighbors

app = Flask(__name__)

# Sample property data
properties = pd.DataFrame([
    {'id': 1, 'title': 'Property 1', 'description': 'Beautiful 3-bedroom house', 'features': [1, 0, 1, 0]},
    {'id': 2, 'title': 'Property 2', 'description': 'Modern apartment in the city center', 'features': [0, 1, 0, 1]},
    {'id': 3, 'title': 'Property 3', 'description': 'Cozy cottage', 'features': [1, 1, 0, 0]},
    {'id': 4, 'title': 'Property 4', 'description': 'Luxury villa', 'features': [0, 0, 1, 1]}
])

# Train a simple recommendation model
model = NearestNeighbors(n_neighbors=2, algorithm='auto').fit(list(properties['features']))

@app.route('/api/recommend', methods=['POST'])
def recommend():
    user_preferences = request.json['preferences']
    distances, indices = model.kneighbors([user_preferences])
    recommended_properties = properties.iloc[indices[0]].to_dict(orient='records')
    return jsonify(recommended_properties)

if __name__ == '__main__':
    app.run(debug=True)
from flask import Flask, request, jsonify
import pandas as pd
from sklearn.neighbors import NearestNeighbors
from geopy.distance import geodesic

app = Flask(__name__)

# Sample property data with geospatial coordinates
properties = pd.DataFrame([
    {'id': 1, 'title': 'Property 1', 'description': 'Beautiful 3-bedroom house', 'lat': -1.292066, 'lng': 36.821946, 'features': [1, 0, 1, 0]},
    {'id': 2, 'title': 'Property 2', 'description': 'Modern apartment in the city center', 'lat': -1.28333, 'lng': 36.81667, 'features': [0, 1, 0, 1]},
    {'id': 3, 'title': 'Property 3', 'description': 'Cozy cottage', 'lat': -1.30000, 'lng': 36.80000, 'features': [1, 1, 0, 0]},
    {'id': 4, 'title': 'Property 4', 'description': 'Luxury villa', 'lat': -1.31000, 'lng': 36.81000, 'features': [0, 0, 1, 1]}
])

# Train a simple recommendation model
model = NearestNeighbors(n_neighbors=2, algorithm='auto').fit(list(properties['features']))

@app.route('/api/recommend', methods=['POST'])
def recommend():
    user_preferences = request.json['preferences']
    user_location = request.json['location']
    distances, indices = model.kneighbors([user_preferences])
    recommended_properties = properties.iloc[indices[0]].to_dict(orient='records')

    # Filter recommendations based on proximity to user's location
    location_based_recommendations = []
    for property in recommended_properties:
        property_location = (property['lat'], property['lng'])
        distance = geodesic(user_location, property_location).km
        if distance <= 10:  # Example: recommend properties within 10 km radius
            location_based_recommendations.append(property)

    return jsonify(location_based_recommendations)

if __name__ == '__main__':
    app.run(debug=True)
from flask import Flask, request, jsonify
from sklearn.neighbors import NearestNeighbors
import pandas as pd

app = Flask(__name__)

# Sample data
data = {
    'user_id': [1, 2, 3, 4],
    'property_id': [101, 102, 103, 104],
    'rating': [5, 4, 3, 5]
}
df = pd.DataFrame(data)

# Train the recommendation model
model = NearestNeighbors(n_neighbors=2, algorithm='auto').fit(df[['user_id', 'property_id']])

@app.route('/recommend', methods=['POST'])
def recommend():
    user_id = request.json['user_id']
    distances, indices = model.kneighbors([[user_id, 0]])
    recommendations = df.iloc[indices[0]]['property_id'].tolist()
    return jsonify(recommendations)

if __name__ == '__main__':
    app.run(debug=True)
class DynamicPricing:
    def __init__(self, base_price, demand_factor, seasonality_factor, property_factor):
        self.base_price = base_price
        self.demand_factor = demand_factor
        self.seasonality_factor = seasonality_factor
        self.property_factor = property_factor

    def calculate_price(self):
        return self.base_price * self.demand_factor * self.seasonality_factor * self.property_factor

# Example usage
pricing = DynamicPricing(base_price=100, demand_factor=1.2, seasonality_factor=1.1, property_factor=1.05)
final_price = pricing.calculate_price()
print(f"Final Price: {final_price}")
class Availability:
    def __init__(self, bookings):
        self.bookings = bookings

    def is_available(self, start_date, end_date):
        for booking in self.bookings:
            if start_date < booking['end_date'] and end_date > booking['start_date']:
                return False
        return True

# Example usage
bookings = [{'start_date': '2024-09-01', 'end_date': '2024-09-10'}, {'start_date': '2024-09-15', 'end_date': '2024-09-20'}]
availability = Availability(bookings)
print(availability.is_available('2024-09-11', '2024-09-14'))  # Should return True
class Property:
    def __init__(self, id, amenities, price, location):
        self.id = id
        self.amenities = amenities
        self.price = price
        self.location = location

class SearchService:
    def __init__(self, properties):
        self.properties = properties

    def search(self, filters):
        results = self.properties
        if 'amenities' in filters:
            results = [p for p in results if all(a in p.amenities for a in filters['amenities'])]
        if 'price_range' in filters:
            results = [p for p in results if filters['price_range'][0] <= p.price <= filters['price_range'][1]]
        if 'location' in filters:
            results = [p for p in results if filters['location'] in p.location]
        return results

# Example usage
properties = [
    Property(id=1, amenities=['wifi', 'pool'], price=150, location='Nairobi'),
    Property(id=2, amenities=['wifi'], price=100, location='Mombasa')
]
search_service = SearchService(properties)
filters = {'amenities': ['wifi'], 'price_range': [50, 200], 'location': 'Nairobi'}
results = search_service.search(filters)
for property in results:
    print(f"Property ID: {property.id}")class User:
    def __init__(self, id, name, email):
        self.id = id
        self.name = name
        self.email = email

class Host(User):
    def __init__(self, id, name, email, listings, booking_history, communication_preferences):
        super().__init__(id, name, email)
        self.listings = listings
        self.booking_history = booking_history
        self.communication_preferences = communication_preferences

# Example usage
host = Host(
    id=1,
    name='John Doe',
    email='john@example.com',
    listings=['Property1', 'Property2'],
    booking_history=['Booking1', 'Booking2'],
    communication_preferences={'email': True, 'sms': False}
)
print(f"Host Name: {host.name}, Listings: {host.listings}")
class DynamicPricing:
    def __init__(self, base_price, demand_factor, seasonality_factor, property_factor, competitor_prices):
        self.base_price = base_price
        self.demand_factor = demand_factor
        self.seasonality_factor = seasonality_factor
        self.property_factor = property_factor
        self.competitor_prices = competitor_prices

    def calculate_price(self):
        competitor_adjustment = sum(self.competitor_prices) / len(self.competitor_prices)
        return self.base_price * self.demand_factor * self.seasonality_factor * self.property_factor * competitor_adjustment

# Example usage
pricing = DynamicPricing(base_price=100, demand_factor=1.2, seasonality_factor=1.1, property_factor=1.05, competitor_prices=[95, 105, 110])
final_price = pricing.calculate_price()
print(f"Final Price: {final_price}")
from datetime import datetime

class Availability:
    def __init__(self, bookings):
        self.bookings = bookings

    def is_available(self, start_date, end_date):
        start_date = datetime.strptime(start_date, '%Y-%m-%d')
        end_date = datetime.strptime(end_date, '%Y-%m-%d')
        for booking in self.bookings:
            booking_start = datetime.strptime(booking['start_date'], '%Y-%m-%d')
            booking_end = datetime.strptime(booking['end_date'], '%Y-%m-%d')
            if start_date < booking_end and end_date > booking_start:
                return False
        return True

# Example usage
bookings = [{'start_date': '2024-09-01', 'end_date': '2024-09-10'}, {'start_date': '2024-09-15', 'end_date': '2024-09-20'}]
availability = Availability(bookings)
print(availability.is_available('2024-09-11', '2024-09-14'))  # Should return True
class Property:
    def __init__(self, id, amenities, price, location, bedrooms, bathrooms, property_type):
        self.id = id
        self.amenities = amenities
        self.price = price
        self.location = location
        self.bedrooms = bedrooms
        self.bathrooms = bathrooms
        self.property_type = property_type

class SearchService:
    def __init__(self, properties):
        self.properties = properties

    def search(self, filters):
        results = self.properties
        if 'amenities' in filters:
            results = [p for p in results if all(a in p.amenities for a in filters['amenities'])]
        if 'price_range' in filters:
            results = [p for p in results if filters['price_range'][0] <= p.price <= filters['price_range'][1]]
        if 'location' in filters:
            results = [p for p in results if filters['location'] in p.location]
        if 'bedrooms' in filters:
            results = [p for p in results if p.bedrooms >= filters['bedrooms']]
        if 'bathrooms' in filters:
            results = [p for p in results if p.bathrooms >= filters['bathrooms']]
        if 'property_type' in filters:
            results = [p for p in results if p.property_type == filters['property_type']]
        return results

# Example usage
properties = [
    Property(id=1, amenities=['wifi', 'pool'], price=150, location='Nairobi', bedrooms=3, bathrooms=2, property_type='apartment'),
    Property(id=2, amenities=['wifi'], price=100, location='Mombasa', bedrooms=2, bathrooms=1, property_type='house')
]
search_service = SearchService(properties)
filters = {'amenities': ['wifi'], 'price_range': [50, 200], 'location': 'Nairobi', 'bedrooms': 2, 'property_type': 'apartment'}
results = search_service.search(filters)
for property in results:
    print(f"Property ID: {property.id}")
class User:
    def __init__(self, id, name, email):
        self.id = id
        self.name = name
        self.email = email

class Host(User):
    def __init__(self, id, name, email, listings, booking_history, communication_preferences, rating, response_time):
        super().__init__(id, name, email)
        self.listings = listings
        self.booking_history = booking_history
        self.communication_preferences = communication_preferences
        self.rating = rating
        self.response_time = response_time

    def update_rating(self, new_rating):
        self.rating = (self.rating + new_rating) / 2

    def update_response_time(self, new_response_time):
        self.response_time = new_response_time

# Example usage
host = Host(
    id=1,
    name='John Doe',
    email='john@example.com',
    listings=['Property1', 'Property2'],
    booking_history=['Booking1', 'Booking2'],
    communication_preferences={'email': True, 'sms': False},
    rating=4.5,
    response_time='2 hours'
)
host.update_rating(5.0)
host.update_response_time('1 hour')
print(f"Host Name: {host.name}, Listings: {host.listings}, Rating: {host.rating}, Response Time: {host.response_time}")
class DynamicPricing:
    def __init__(self, base_price, demand_factor, seasonality_factor, property_factor, competitor_prices):
        self.base_price = base_price
        self.demand_factor = demand_factor
        self.seasonality_factor = seasonality_factor
        self.property_factor = property_factor
        self.competitor_prices = competitor_prices

    def calculate_price(self):
        competitor_adjustment = sum(self.competitor_prices) / len(self.competitor_prices)
        return self.base_price * self.demand_factor * self.seasonality_factor * self.property_factor * competitor_adjustment

# Example usage
pricing = DynamicPricing(base_price=100, demand_factor=1.2, seasonality_factor=1.1, property_factor=1.05, competitor_prices=[95, 105, 110])
final_price = pricing.calculate_price()
print(f"Final Price: {final_price}")
from datetime import datetime

class Availability:
    def __init__(self, bookings):
        self.bookings = bookings

    def is_available(self, start_date, end_date):
        start_date = datetime.strptime(start_date, '%Y-%m-%d')
        end_date = datetime.strptime(end_date, '%Y-%m-%d')
        for booking in self.bookings:
            booking_start = datetime.strptime(booking['start_date'], '%Y-%m-%d')
            booking_end = datetime.strptime(booking['end_date'], '%Y-%m-%d')
            if start_date < booking_end and end_date > booking_start:
                return False
        return True

# Example usage
bookings = [{'start_date': '2024-09-01', 'end_date': '2024-09-10'}, {'start_date': '2024-09-15', 'end_date': '2024-09-20'}]
availability = Availability(bookings)
print(availability.is_available('2024-09-11', '2024-09-14'))  # Should return True
class PropertyBooking:
    def __init__(self, properties):
        self.properties = properties

    def get_dynamic_price(self, property_id, demand_factor, seasonality_factor, competitor_prices):
        property = self.properties[property_id]
        pricing = DynamicPricing(
            base_price=property['base_price'],
            demand_factor=demand_factor,
            seasonality_factor=seasonality_factor,
            property_factor=property['property_factor'],
            competitor_prices=competitor_prices
        )
        return pricing.calculate_price()

    def check_availability(self, property_id, start_date, end_date):
        property = self.properties[property_id]
        availability = Availability(property['bookings'])
        return availability.is_available(start_date, end_date)

# Example usage
properties = {
    1: {
        'base_price': 100,
        'property_factor': 1.05,
        'bookings': [{'start_date': '2024-09-01', 'end_date': '2024-09-10'}, {'start_date': '2024-09-15', 'end_date': '2024-09-20'}]
    }
}
booking_system = PropertyBooking(properties)
print(booking_system.get_dynamic_price(1, 1.2, 1.1, [95, 105, 110]))  # Calculate dynamic price
print(booking_system.check_availability(1, '2024-09-11', '2024-09-14'))  # Check availability
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bookings.db'
db = SQLAlchemy(app)

class Booking(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    property_id = db.Column(db.Integer, nullable=False)
    user_id = db.Column(db.Integer, nullable=False)
    daily_rate = db.Column(db.Float, nullable=False)
    transaction_fee = db.Column(db.Float, default=10.0)
    total_amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(50), nullable=False, default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

@app.route('/calculate-amount', methods=['POST'])
def calculate_amount():
    data = request.json
    daily_rate = data['daily_rate']
    transaction_fee = 10.0
    total_amount = daily_rate + transaction_fee
    return jsonify({"total_amount": total_amount})

if __name__ == '__main__':
    db.create_all()
    app.run(debug=True)
@app.route('/create-booking', methods=['POST'])
def create_booking():
    data = request.json
    daily_rate = data['daily_rate']
    transaction_fee = 10.0
    total_amount = daily_rate + transaction_fee
    new_booking = Booking(
        property_id=data['property_id'],
        user_id=data['user_id'],
        daily_rate=daily_rate,
        transaction_fee=transaction_fee,
        total_amount=total_amount
    )
    db.session.add(new_booking)
    db.session.commit()
    return jsonify({"message": "Booking created successfully", "booking_id": new_booking.id})
@app.route('/hold-funds/<int:booking_id>', methods=['POST'])
def hold_funds(booking_id):
    booking = Booking.query.get_or_404(booking_id)
    if booking.status != 'pending':
        return jsonify({"message": "Funds already held or booking completed"})
    
    # Logic to hold funds securely (placeholder)
    booking.status = 'funds_held'
    db.session.commit()
    return jsonify({"message": "Funds held successfully"})
@app.route('/calculate-multi-day-amount', methods=['POST'])
def calculate_multi_day_amount():
    data = request.json
    daily_rate = data['daily_rate']
    days = data['days']
    transaction_fee = 10.0
    total_amount = (daily_rate * days) + transaction_fee
    return jsonify({"total_amount": total_amount})
@app.route('/complete-booking/<int:booking_id>', methods=['POST'])
def complete_booking(booking_id):
    booking = Booking.query.get_or_404(booking_id)
    if booking.status != 'funds_held':
        return jsonify({"message": "Funds not held or booking already completed"})
    
    commission = booking.total_amount * 0.30
    host_amount = booking.total_amount * 0.70
    # Logic to transfer funds (placeholder)
    booking.status = 'completed'
    db.session.commit()
    return jsonify({"message": "Booking completed successfully", "commission": commission, "host_amount": host_amount})
import React, { useState } from 'react';
import axios from 'axios';

function BookingForm() {
    const [dailyRate, setDailyRate] = useState('');
    const [days, setDays] = useState(1);
    const [totalAmount, setTotalAmount] = useState(null);
    const [transactionFee, setTransactionFee] = useState(10);

    const calculateAmount = async () => {
        const response = await axios.post('/calculate-multi-day-amount', { daily_rate: parseFloat(dailyRate), days: parseInt(days) });
        setTotalAmount(response.data.total_amount);
    };

    const createBooking = async () => {
        const response = await axios.post('/create-booking', {
            property_id: 1, // Example property ID
            user_id: 1, // Example user ID
            daily_rate: parseFloat(dailyRate)
        });
        alert(response.data.message);
    };

    return (
        <div>
            <h1>Book a Property</h1>
            <input
                type="number"
                value={dailyRate}
                onChange={(e) => setDailyRate(e.target.value)}
                placeholder="Enter daily rate"
            />
            <input
                type="number"
                value={days}
                onChange={(e) => setDays(e.target.value)}
                placeholder="Enter number of days"
            />
            <button onClick={calculateAmount}>Calculate Total Amount</button>
            {totalAmount && (
                <div>
                    <p>Daily Rate: ${dailyRate}</p>
                    <p>Transaction Fee: ${transactionFee}</p>
                    <p>Total Amount for {days} day(s): ${totalAmount}</p>
                </div>
            )}
            <button onClick={createBooking}>Create Booking</button>
        </div>
    );
}

export default BookingForm; 
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from sqlalchemy.exc import SQLAlchemyError

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bookings.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

class Booking(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    property_id = db.Column(db.Integer, nullable=False)
    user_id = db.Column(db.Integer, nullable=False)
    daily_rate = db.Column(db.Float, nullable=False)
    transaction_fee = db.Column(db.Float, default=10.0)
    total_amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(50), nullable=False, default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

@app.route('/calculate-amount', methods=['POST'])
def calculate_amount():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        if daily_rate is None or daily_rate <= 0:
            return jsonify({"error": "Invalid daily rate"}), 400
        transaction_fee = 10.0
        total_amount = daily_rate + transaction_fee
        return jsonify({"total_amount": total_amount})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/create-booking', methods=['POST'])
def create_booking():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        if daily_rate is None or daily_rate <= 0:
            return jsonify({"error": "Invalid daily rate"}), 400
        transaction_fee = 10.0
        total_amount = daily_rate + transaction_fee
        new_booking = Booking(
            property_id=data['property_id'],
            user_id=data['user_id'],
            daily_rate=daily_rate,
            transaction_fee=transaction_fee,
            total_amount=total_amount
        )
        db.session.add(new_booking)
        db.session.commit()
        return jsonify({"message": "Booking created successfully", "booking_id": new_booking.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/hold-funds/<int:booking_id>', methods=['POST'])
def hold_funds(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'pending':
            return jsonify({"error": "Funds already held or booking completed"}), 400
        # Logic to hold funds securely (placeholder)
        booking.status = 'funds_held'
        db.session.commit()
        return jsonify({"message": "Funds held successfully"})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/calculate-multi-day-amount', methods=['POST'])
def calculate_multi_day_amount():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        days = data.get('days')
        if daily_rate is None or daily_rate <= 0 or days is None or days <= 0:
            return jsonify({"error": "Invalid daily rate or days"}), 400
        transaction_fee = 10.0
        total_amount = (daily_rate * days) + transaction_fee
        return jsonify({"total_amount": total_amount})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/complete-booking/<int:booking_id>', methods=['POST'])
def complete_booking(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'funds_held':
            return jsonify({"error": "Funds not held or booking already completed"}), 400
        commission = booking.total_amount * 0.30
        host_amount = booking.total_amount * 0.70
        # Logic to transfer funds (placeholder)
        booking.status = 'completed'
        db.session.commit()
        return jsonify({"message": "Booking completed successfully", "commission": commission, "host_amount": host_amount})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    db.create_all()
    app.run(debug=True)
import React, { useState } from 'react';
import axios from 'axios';

function BookingForm() {
    const [dailyRate, setDailyRate] = useState('');
    const [days, setDays] = useState(1);
    const [totalAmount, setTotalAmount] = useState(null);
    const [transactionFee, setTransactionFee] = useState(10);
    const [error, setError] = useState(null);

    const calculateAmount = async () => {
        try {
            const response = await axios.post('/calculate-multi-day-amount', { daily_rate: parseFloat(dailyRate), days: parseInt(days) });
            setTotalAmount(response.data.total_amount);
            setError(null);
        } catch (err) {
            setError(err.response ? err.response.data.error : 'An error occurred');
        }
    };

    const createBooking = async () => {
        try {
            const response = await axios.post('/create-booking', {
                property_id: 1, // Example property ID
                user_id: 1, // Example user ID
                daily_rate: parseFloat(dailyRate)
            });
            alert(response.data.message);
            setError(null);
        } catch (err) {
            setError(err.response ? err.response.data.error : 'An error occurred');
        }
    };

    return (
        <div>
            <h1>Book a Property</h1>
            <input
                type="number"
                value={dailyRate}
                onChange={(e) => setDailyRate(e.target.value)}
                placeholder="Enter daily rate"
            />
            <input
                type="number"
                value={days}
                onChange={(e) => setDays(e.target.value)}
                placeholder="Enter number of days"
            />
            <button onClick={calculateAmount}>Calculate Total Amount</button>
            {error && <p style={{ color: 'red' }}>{error}</p>}
            {totalAmount && (
                <div>
                    <p>Daily Rate: ${dailyRate}</p>
                    <p>Transaction Fee: ${transactionFee}</p>
                    <p>Total Amount for {days} day(s): ${totalAmount}</p>
                </div>
            )}
            <button onClick={createBooking}>Create Booking</button>
        </div>
    );
}

export default BookingForm;
@app.route('/distribute-funds/<int:booking_id>', methods=['POST'])
def distribute_funds(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'funds_held':
            return jsonify({"error": "Funds not held or booking already completed"}), 400
        commission = booking.total_amount * 0.30
        host_amount = booking.total_amount * 0.70
        # Logic to transfer funds securely (placeholder)
        booking.status = 'completed'
        db.session.commit()
        return jsonify({"message": "Funds distributed successfully", "commission": commission, "host_amount": host_amount})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from sqlalchemy.exc import SQLAlchemyError
import stripe

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bookings.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Stripe API keys
stripe.api_key = 'your_stripe_secret_key'

class Booking(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    property_id = db.Column(db.Integer, nullable=False)
    user_id = db.Column(db.Integer, nullable=False)
    daily_rate = db.Column(db.Float, nullable=False)
    transaction_fee = db.Column(db.Float, default=10.0)
    total_amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(50), nullable=False, default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Host(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    stripe_account_id = db.Column(db.String(255), nullable=False)

@app.route('/calculate-amount', methods=['POST'])
def calculate_amount():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        if daily_rate is None or daily_rate <= 0:
            return jsonify({"error": "Invalid daily rate"}), 400
        transaction_fee = 10.0
        total_amount = daily_rate + transaction_fee
        return jsonify({"total_amount": total_amount})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/create-booking', methods=['POST'])
def create_booking():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        if daily_rate is None or daily_rate <= 0:
            return jsonify({"error": "Invalid daily rate"}), 400
        transaction_fee = 10.0
        total_amount = daily_rate + transaction_fee
        new_booking = Booking(
            property_id=data['property_id'],
            user_id=data['user_id'],
            daily_rate=daily_rate,
            transaction_fee=transaction_fee,
            total_amount=total_amount
        )
        db.session.add(new_booking)
        db.session.commit()
        return jsonify({"message": "Booking created successfully", "booking_id": new_booking.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/hold-funds/<int:booking_id>', methods=['POST'])
def hold_funds(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'pending':
            return jsonify({"error": "Funds already held or booking completed"}), 400
        # Logic to hold funds securely (placeholder)
        booking.status = 'funds_held'
        db.session.commit()
        return jsonify({"message": "Funds held successfully"})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/calculate-multi-day-amount', methods=['POST'])
def calculate_multi_day_amount():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        days = data.get('days')
        if daily_rate is None or daily_rate <= 0 or days is None or days <= 0:
            return jsonify({"error": "Invalid daily rate or days"}), 400
        transaction_fee = 10.0
        total_amount = (daily_rate * days) + transaction_fee
        return jsonify({"total_amount": total_amount})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/complete-booking/<int:booking_id>', methods=['POST'])
def complete_booking(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'funds_held':
            return jsonify({"error": "Funds not held or booking already completed"}), 400
        commission = booking.total_amount * 0.30
        host_amount = booking.total_amount * 0.70
        # Logic to transfer funds (placeholder)
        booking.status = 'completed'
        db.session.commit()
        return jsonify({"message": "Booking completed successfully", "commission": commission, "host_amount": host_amount})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/distribute-funds/<int:booking_id>', methods=['POST'])
def distribute_funds(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'funds_held':
            return jsonify({"error": "Funds not held or booking already completed"}), 400
        commission = booking.total_amount * 0.30
        host_amount = booking.total_amount * 0.70
        host = Host.query.filter_by(user_id=booking.user_id).first()
        if not host:
            return jsonify({"error": "Host not found"}), 404
        # Transfer funds to host using Stripe
        stripe.Transfer.create(
            amount=int(host_amount * 100),  # Amount in cents
            currency='usd',
            destination=host.stripe_account_id,
            transfer_group=booking.id
        )
        booking.status = 'completed'
        db.session.commit()
        return jsonify({"message": "Funds distributed successfully", "commission": commission, "host_amount": host_amount})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    db.create_all()
    app.run(debug=True)
@app.route('/register-host', methods=['POST'])
def register_host():
    try:
        data = request.json
        user_id = data.get('user_id')
        stripe_account_id = data.get('stripe_account_id')
        if not user_id or not stripe_account_id:
            return jsonify({"error": "User ID and Stripe Account ID are required"}), 400
        new_host = Host(user_id=user_id, stripe_account_id=stripe_account_id)
        db.session.add(new_host)
        db.session.commit()
        return jsonify({"message": "Host registered successfully"})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    db.create_all()
    app.run(debug=True)
import React, { useState } from 'react';
import axios from 'axios';

function HostRegistrationForm() {
    const [userId, setUserId] = useState('');
    const [stripeAccountId, setStripeAccountId] = useState('');
    const [message, setMessage] = useState(null);
    const [error, setError] = useState(null);

    const registerHost = async () => {
        try {
            const response = await axios.post('/register-host', {
                user_id: parseInt(userId),
                stripe_account_id: stripeAccountId
            });
            setMessage(response.data.message);
            setError(null);
        } catch (err) {
            setError(err.response ? err.response.data.error : 'An error occurred');
        }
    };

    return (
        <div>
            <h1>Host Registration</h1>
            <input
                type="number"
                value={userId}
                onChange={(e) => setUserId(e.target.value)}
                placeholder="Enter User ID"
            />
            <input
                type="text"
                value={stripeAccountId}
                onChange={(e) => setStripeAccountId(e.target.value)}
                placeholder="Enter Stripe Account ID"
            />
            <button onClick={registerHost}>Register</button>
            {error && <p style={{ color: 'red' }}>{error}</p>}
            {message && <p style={{ color: 'green' }}>{message}</p>}
        </div>
    );
}

export default HostRegistrationForm;
import React, { useState } from 'react';
import axios from 'axios';

function BookingForm() {
    const [dailyRate, setDailyRate] = useState('');
    const [days, setDays] = useState(1);
    const [totalAmount, setTotalAmount] = useState(null);
    const [transactionFee, setTransactionFee] = useState(10);
    const [error, setError] = useState(null);

    const calculateAmount = async () => {
        try {
            const response = await axios.post('/calculate-multi-day-amount', {
                daily_rate: parseFloat(dailyRate),
                days: parseInt(days)
            });
            setTotalAmount(response.data.total_amount);
            setError(null);
        } catch (err) {
            setError(err.response ? err.response.data.error : 'An error occurred');
        }
    };

    const createBooking = async () => {
        try {
            const response = await axios.post('/create-booking', {
                property_id: 1, // Example property ID
                user_id: 1, // Example user ID
                daily_rate: parseFloat(dailyRate)
            });
            alert(response.data.message);
            setError(null);
        } catch (err) {
            setError(err.response ? err.response.data.error : 'An error occurred');
        }
    };

    return (
        <div>
            <h1>Book a Property</h1>
            <input
                type="number"
                value={dailyRate}
                onChange={(e) => setDailyRate(e.target.value)}
                placeholder="Enter daily rate"
            />
            <input
                type="number"
                value={days}
                onChange={(e) => setDays(e.target.value)}
                placeholder="Enter number of days"
            />
            <button onClick={calculateAmount}>Calculate Total Amount</button>
            {error && <p style={{ color: 'red' }}>{error}</p>}
            {totalAmount && (
                <div>
                    <p>Daily Rate: ${dailyRate}</p>
                    <p>Transaction Fee: ${transactionFee}</p>
                    <p>Total Amount for {days} day(s): ${totalAmount}</p>
                </div>
            )}
            <button onClick={createBooking}>Create Booking</button>
        </div>
    );
}

export default BookingForm;
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from sqlalchemy.exc import SQLAlchemyError
import stripe
import paypalrestsdk

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bookings.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Stripe API keys
stripe.api_key = 'your_stripe_secret_key'

# PayPal configuration
paypalrestsdk.configure({
    "mode": "sandbox",  # sandbox or live
    "client_id": "your_paypal_client_id",
    "client_secret": "your_paypal_client_secret"
})

class Booking(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    property_id = db.Column(db.Integer, nullable=False)
    user_id = db.Column(db.Integer, nullable=False)
    daily_rate = db.Column(db.Float, nullable=False)
    transaction_fee = db.Column(db.Float, default=10.0)
    total_amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(50), nullable=False, default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Host(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    stripe_account_id = db.Column(db.String(255), nullable=False)
    paypal_account_id = db.Column(db.String(255), nullable=True)
    bank_account = db.Column(db.String(255), nullable=True)

@app.route('/calculate-amount', methods=['POST'])
def calculate_amount():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        if daily_rate is None or daily_rate <= 0:
            return jsonify({"error": "Invalid daily rate"}), 400
        transaction_fee = 10.0
        total_amount = daily_rate + transaction_fee
        return jsonify({"total_amount": total_amount})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/create-booking', methods=['POST'])
def create_booking():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        if daily_rate is None or daily_rate <= 0:
            return jsonify({"error": "Invalid daily rate"}), 400
        transaction_fee = 10.0
        total_amount = daily_rate + transaction_fee
        new_booking = Booking(
            property_id=data['property_id'],
            user_id=data['user_id'],
            daily_rate=daily_rate,
            transaction_fee=transaction_fee,
            total_amount=total_amount
        )
        db.session.add(new_booking)
        db.session.commit()
        return jsonify({"message": "Booking created successfully", "booking_id": new_booking.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/hold-funds/<int:booking_id>', methods=['POST'])
def hold_funds(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'pending':
            return jsonify({"error": "Funds already held or booking completed"}), 400
        # Logic to hold funds securely (placeholder)
        booking.status = 'funds_held'
        db.session.commit()
        return jsonify({"message": "Funds held successfully"})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/calculate-multi-day-amount', methods=['POST'])
def calculate_multi_day_amount():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        days = data.get('days')
        if daily_rate is None or daily_rate <= 0 or days is None or days <= 0:
            return jsonify({"error": "Invalid daily rate or days"}), 400
        transaction_fee = 10.0
        total_amount = (daily_rate * days) + transaction_fee
        return jsonify({"total_amount": total_amount})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/complete-booking/<int:booking_id>', methods=['POST'])
def complete_booking(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'funds_held':
            return jsonify({"error": "Funds not held or booking already completed"}), 400
        # Deduct commission and transaction fee
        commission = booking.total_amount * 0.30
        host_amount = booking.total_amount - commission - booking.transaction_fee
        # Logic to transfer funds to host (placeholder)
        booking.status = 'completed'
        db.session.commit()
        return jsonify({"message": "Booking completed successfully", "host_amount": host_amount})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/add-host', methods=['POST'])
def add_host():
    try:
        data = request.json
        new_host = Host(
            user_id=data['user_id'],
            stripe_account_id=data.get('stripe_account_id'),
            paypal_account_id=data.get('paypal_account_id'),
            bank_account=data.get('bank_account')
        )
        db.session.add(new_host)
        db.session.commit()
        return jsonify({"message": "Host added successfully", "host_id": new_host.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
@app.route('/complete-booking/<int:booking_id>', methods=['POST'])
def complete_booking(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'funds_held':
            return jsonify({"error": "Funds not held or booking already completed"}), 400
        
        # Calculate commission and host amount
        commission = booking.total_amount * 0.30
        host_amount = booking.total_amount - commission - booking.transaction_fee
        
        # Transfer funds to host (Stripe example)
        stripe.Transfer.create(
            amount=int(host_amount * 100),  # amount in cents
            currency='usd',
            destination=booking.host.stripe_account_id,
            transfer_group=booking.id
        )
        
        # Update booking status
        booking.status = 'completed'
        db.session.commit()
        
        return jsonify({"message": "Booking completed successfully", "host_amount": host_amount})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from sqlalchemy.exc import SQLAlchemyError
import stripe
import paypalrestsdk

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bookings.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Stripe API keys
stripe.api_key = 'your_stripe_secret_key'

# PayPal configuration
paypalrestsdk.configure({
    "mode": "sandbox",  # sandbox or live
    "client_id": "your_paypal_client_id",
    "client_secret": "your_paypal_client_secret"
})

class Booking(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    property_id = db.Column(db.Integer, nullable=False)
    user_id = db.Column(db.Integer, nullable=False)
    daily_rate = db.Column(db.Float, nullable=False)
    transaction_fee = db.Column(db.Float, default=10.0)
    total_amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(50), nullable=False, default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Host(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    stripe_account_id = db.Column(db.String(255), nullable=False)
    paypal_account_id = db.Column(db.String(255), nullable=True)
    bank_account = db.Column(db.String(255), nullable=True)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    bank_account = db.Column(db.String(255), nullable=True)

@app.route('/calculate-amount', methods=['POST'])
def calculate_amount():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        if daily_rate is None or daily_rate <= 0:
            return jsonify({"error": "Invalid daily rate"}), 400
        transaction_fee = 10.0
        total_amount = daily_rate + transaction_fee
        return jsonify({"total_amount": total_amount})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/create-booking', methods=['POST'])
def create_booking():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        if daily_rate is None or daily_rate <= 0:
            return jsonify({"error": "Invalid daily rate"}), 400
        transaction_fee = 10.0
        total_amount = daily_rate + transaction_fee
        new_booking = Booking(
            property_id=data['property_id'],
            user_id=data['user_id'],
            daily_rate=daily_rate,
            transaction_fee=transaction_fee,
            total_amount=total_amount
        )
        db.session.add(new_booking)
        db.session.commit()
        return jsonify({"message": "Booking created successfully", "booking_id": new_booking.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/hold-funds/<int:booking_id>', methods=['POST'])
def hold_funds(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'pending':
            return jsonify({"error": "Funds already held or booking completed"}), 400
        # Logic to hold funds securely (placeholder)
        booking.status = 'funds_held'
        db.session.commit()
        return jsonify({"message": "Funds held successfully"})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/calculate-multi-day-amount', methods=['POST'])
def calculate_multi_day_amount():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        days = data.get('days')
        if daily_rate is None or daily_rate <= 0 or days is None or days <= 0:
            return jsonify({"error": "Invalid daily rate or days"}), 400
        transaction_fee = 10.0
        total_amount = (daily_rate * days) + transaction_fee
        return jsonify({"total_amount": total_amount})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/complete-booking/<int:booking_id>', methods=['POST'])
def complete_booking(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'funds_held':
            return jsonify({"error": "Funds not held or booking already completed"}), 400
        
        # Calculate commission and host amount
        commission = booking.total_amount * 0.30
        host_amount = booking.total_amount - commission - booking.transaction_fee
        
        # Transfer funds to host
        if booking.host.stripe_account_id:
            stripe.Transfer.create(
                amount=int(host_amount * 100),  # amount in cents
                currency='usd',
                destination=booking.host.stripe_account_id,
                transfer_group=booking.id
            )
        elif booking.host.paypal_account_id:
            # PayPal transfer logic (placeholder)
            pass
        elif booking.host.bank_account:
            # Bank transfer logic (placeholder)
            pass
        
        # Update booking status
        booking.status = 'completed'
        db.session.commit()
        
        return jsonify({"message": "Booking completed successfully", "host_amount": host_amount})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/add-host', methods=['POST'])
def add_host():
    try:
        data = request.json
        new_host = Host(
            user_id=data['user_id'],
            stripe_account_id=data.get('stripe_account_id'),
            paypal_account_id=data.get('paypal_account_id'),
            bank_account=data.get('bank_account')
        )
        db.session.add(new_host)
        db.session.commit()
        return jsonify({"message": "Host added successfully", "host_id": new_host.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/add-user', methods=['POST'])
def add_user():
    try:
        data = request.json
        new_user = User(
            bank_account=data.get('bank_account')
        )
        db.session.add(new_user)
        db.session.commit()
        return jsonify({"message": "User added successfully", "user_id": new_user.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from sqlalchemy.exc import SQLAlchemyError
import stripe
import paypalrestsdk

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bookings.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Stripe API keys
stripe.api_key = 'your_stripe_secret_key'

# PayPal configuration
paypalrestsdk.configure({
    "mode": "sandbox",  # sandbox or live
    "client_id": "your_paypal_client_id",
    "client_secret": "your_paypal_client_secret"
})

class Booking(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    property_id = db.Column(db.Integer, nullable=False)
    user_id = db.Column(db.Integer, nullable=False)
    daily_rate = db.Column(db.Float, nullable=False)
    transaction_fee = db.Column(db.Float, default=10.0)
    total_amount = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(50), nullable=False, default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Host(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, nullable=False)
    stripe_account_id = db.Column(db.String(255), nullable=True)
    paypal_account_id = db.Column(db.String(255), nullable=True)
    bank_account = db.Column(db.String(255), nullable=True)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    bank_account = db.Column(db.String(255), nullable=True)

@app.route('/calculate-amount', methods=['POST'])
def calculate_amount():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        if daily_rate is None or daily_rate <= 0:
            return jsonify({"error": "Invalid daily rate"}), 400
        transaction_fee = 10.0
        total_amount = daily_rate + transaction_fee
        return jsonify({"total_amount": total_amount})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/create-booking', methods=['POST'])
def create_booking():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        if daily_rate is None or daily_rate <= 0:
            return jsonify({"error": "Invalid daily rate"}), 400
        transaction_fee = 10.0
        total_amount = daily_rate + transaction_fee
        new_booking = Booking(
            property_id=data['property_id'],
            user_id=data['user_id'],
            daily_rate=daily_rate,
            transaction_fee=transaction_fee,
            total_amount=total_amount
        )
        db.session.add(new_booking)
        db.session.commit()
        return jsonify({"message": "Booking created successfully", "booking_id": new_booking.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/hold-funds/<int:booking_id>', methods=['POST'])
def hold_funds(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'pending':
            return jsonify({"error": "Funds already held or booking completed"}), 400
        # Logic to hold funds securely (placeholder)
        booking.status = 'funds_held'
        db.session.commit()
        return jsonify({"message": "Funds held successfully"})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/calculate-multi-day-amount', methods=['POST'])
def calculate_multi_day_amount():
    try:
        data = request.json
        daily_rate = data.get('daily_rate')
        days = data.get('days')
        if daily_rate is None or daily_rate <= 0 or days is None or days <= 0:
            return jsonify({"error": "Invalid daily rate or days"}), 400
        transaction_fee = 10.0
        total_amount = (daily_rate * days) + transaction_fee
        return jsonify({"total_amount": total_amount})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/complete-booking/<int:booking_id>', methods=['POST'])
def complete_booking(booking_id):
    try:
        booking = Booking.query.get_or_404(booking_id)
        if booking.status != 'funds_held':
            return jsonify({"error": "Funds not held or booking already completed"}), 400
        
        # Calculate commission and host amount
        commission = booking.total_amount * 0.30
        host_amount = booking.total_amount - commission - booking.transaction_fee
        
        # Transfer funds to host
        if booking.host.stripe_account_id:
            stripe.Transfer.create(
                amount=int(host_amount * 100),  # amount in cents
                currency='usd',
                destination=booking.host.stripe_account_id,
                transfer_group=booking.id
            )
        elif booking.host.paypal_account_id:
            # PayPal transfer logic (placeholder)
            pass
        elif booking.host.bank_account:
            # Bank transfer logic (placeholder)
            pass
        
        # Update booking status
        booking.status = 'completed'
        db.session.commit()
        
        return jsonify({"message": "Booking completed successfully", "host_amount": host_amount})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/add-host', methods=['POST'])
def add_host():
    try:
        data = request.json
        new_host = Host(
            user_id=data['user_id'],
            stripe_account_id=data.get('stripe_account_id'),
            paypal_account_id=data.get('paypal_account_id'),
            bank_account=data.get('bank_account')
        )
        db.session.add(new_host)
        db.session.commit()
        return jsonify({"message": "Host added successfully", "host_id": new_host.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/add-user', methods=['POST'])
def add_user():
    try:
        data = request.json
        new_user = User(
            bank_account=data.get('bank_account')
        )
        db.session.add(new_user)
        db.session.commit()
        return jsonify({"message": "User added successfully", "user_id": new_user.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
from flask import Flask, request, jsonify, render_template
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from sqlalchemy.exc import SQLAlchemyError
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///listings.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

class Listing(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=False)
    price = db.Column(db.Float, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class Host(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), nullable=False)
    phone = db.Column(db.String(20), nullable=True)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload-listing', methods=['POST'])
def upload_listing():
    try:
        data = request.form
        new_listing = Listing(
            title=data['title'],
            description=data['description'],
            price=data['price']
        )
        db.session.add(new_listing)
        db.session.commit()
        
        # Send notification
        send_notification(new_listing)
        
        return jsonify({"message": "Listing uploaded successfully", "listing_id": new_listing.id})
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

def send_notification(listing):
    host = Host.query.first()  # Assuming a single host for simplicity
    if host:
        subject = "New Property Listing Uploaded"
        body = f"""
        A new property listing has been uploaded:
        Title: {listing.title}
        Description: {listing.description}
        Price: ${listing.price}
        
        Please ensure your space is suitable for hosting by providing a clean, safe, and comfortable setting for guests. 
        Prepare your space by decluttering, stocking essential items like toiletries and linens, and adding personal touches for a welcoming atmosphere.
        Create an BookEase listing by writing a thorough description, setting prices, and sharing high-quality images of your space. Listing your space is free, with BookEase charging a commission fee of 30% only upon booking confirmation and Guest completion stay.
        Familiarize yourself with local laws and taxes related to short-term rentals, including obtaining permits and fulfilling tax.
        Hosts are expected to meet standards in reservation management, communication, accuracy in listings, and cleanliness. Maintaining excellent review ratings is also crucial.
        Prioritize prompt responses to guest inquiries and booking requests to demonstrate attentiveness and consideration.
        Strive to avoid canceling confirmed bookings as it can have adverse effects on your hosting reputation.
        Always stay alert on the BookEase platform or through push notifications and email when a guest makes a booking.
        """
        send_email(host.email, subject, body)
        send_sms(host.phone, body)

def send_email(to_email, subject, body):
    from_email = "your_email@example.com"
    password = "your_email_password"
    
    msg = MIMEMultipart()
    msg['From'] = from_email
    msg['To'] = to_email
    msg['Subject'] = subject
    msg.attach(MIMEText(body, 'plain'))
    
    server = smtplib.SMTP('smtp.example.com', 587)
    server.starttls()
    server.login(from_email, password)
    text = msg.as_string()
    server.sendmail(from_email, to_email, text)
    server.quit()

def send_sms(to_phone, body):
    # Implement SMS sending logic here (e.g., using Twilio)
    pass

@app.route('/terms-and-conditions')
def terms_and_conditions():
    return render_template('terms_and_conditions.html')

if __name__ == '__main__':
    app.run(debug=True)
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel
import pandas as pd

# Sample data
data = {'user_id': [1, 2, 3], 'content': ['beach house', 'mountain cabin', 'city apartment']}
df = pd.DataFrame(data)

# TF-IDF Vectorizer
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['content'])

# Compute cosine similarity
cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)

# Function to get recommendations
def get_recommendations(user_id, cosine_sim=cosine_sim):
    idx = df.index[df['user_id'] == user_id].tolist()[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:4]
    content_indices = [i[0] for i in sim_scores]
    return df['content'].iloc[content_indices]

# Example usage
print(get_recommendations(1))
class Booking:
    def __init__(self, booking_id, user_id, host_id, paid, status):
        self.booking_id = booking_id
        self.user_id = user_id
        self.host_id = host_id
        self.paid = paid
        self.status = status

    def cancel_booking(self):
        if not self.is_host_reachable(self.host_id):
            self.process_cancellation()
        else:
            print("Host is reachable. No need to cancel.")

    def is_host_reachable(self, host_id):
        # Logic to check if the host is reachable
        pass

    def process_cancellation(self):
        if self.paid:
            self.offer_alternative()
        else:
            self.cancel_unpaid_booking()

    def offer_alternative(self):
        # Logic to offer an alternative booking
        alternative_host_id = self.find_alternative_host()
        if alternative_host_id:
            self.update_booking(alternative_host_id)
        else:
            self.process_refund()

    def find_alternative_host(self):
        # Logic to find an alternative host
        pass

    def update_booking(self, new_host_id):
        self.host_id = new_host_id
        print(f"Booking updated to new host: {new_host_id}")

    def process_refund(self):
        # Logic to process refund
        print("Processing refund...")

    def cancel_unpaid_booking(self):
        self.status = "Cancelled"
        print("Booking cancelled due to non-payment.")class Booking:
    # Existing methods...

    def apply_penalty(self, host_id):
        # Logic to apply penalty to the host
        print(f"Applying penalty to host: {host_id}")

    def block_host(self, host_id):
        # Logic to block and erase host details
        print(f"Blocking host: {host_id}")

    def process_cancellation(self):
        if self.paid:
            self.offer_alternative()
        else:
            self.cancel_unpaid_booking()
        self.apply_penalty(self.host_id)class Booking:
    # Existing methods...

    def process_refund(self):
        # Logic to process refund within 14 business days
        print("Processing refund within 14 business days...")
class Booking:
    def __init__(self, booking_id, user_id, host_id, paid, status):
        self.booking_id = booking_id
        self.user_id = user_id
        self.host_id = host_id
        self.paid = paid
        self.status = status

    def cancel_booking(self):
        if not self.is_host_reachable(self.host_id):
            self.process_cancellation()
        else:
            print("Host is reachable. No need to cancel.")

    def is_host_reachable(self, host_id):
        # Logic to check if the host is reachable
        # This could involve checking the host's last activity or sending a ping
        return False  # Placeholder for actual logic

    def process_cancellation(self):
        if self.paid:
            self.offer_alternative()
        else:
            self.cancel_unpaid_booking()
        self.apply_penalty(self.host_id)

    def offer_alternative(self):
        alternative_host_id = self.find_alternative_host()
        if alternative_host_id:
            self.update_booking(alternative_host_id)
        else:
            self.process_refund()

    def find_alternative_host(self):
        # Logic to find an alternative host with similar features and location
        # This could involve querying the database for available hosts
        return "alternative_host_id"  # Placeholder for actual logic

    def update_booking(self, new_host_id):
        self.host_id = new_host_id
        self.status = "Updated"
        print(f"Booking updated to new host: {new_host_id}")

    def process_refund(self):
        # Logic to process refund within 14 business days
        print("Processing refund within 14 business days...")
        # Placeholder for actual refund processing logic

    def cancel_unpaid_booking(self):
        self.status = "Cancelled"
        print("Booking cancelled due to non-payment.")

    def apply_penalty(self, host_id):
        # Logic to apply penalty to the host
        print(f"Applying penalty to host: {host_id}")
        self.enforce_penalty(host_id)

    def enforce_penalty(self, host_id):
        # Logic to enforce penalty, such as blocking updates for 30 days
        print(f"Host {host_id} is penalized for 30 days.")
        # Logic to handle repeat offenses
        self.check_repeat_offenses(host_id)

    def check_repeat_offenses(self, host_id):
        # Logic to check for repeat offenses and block host if necessary
        print(f"Checking repeat offenses for host: {host_id}")
        # Placeholder for actual logic to block and erase host details
class Booking:
    # Existing methods...

    def process_refund(self):
        # Logic to process refund within 14 business days
        print("Processing refund within 14 business days...")
        # Placeholder for actual refund processing logic
        self.initiate_refund()

    def initiate_refund(self):
        # Detailed logic to initiate the refund process
        print("Initiating refund process...")
        # Placeholder for actual refund initiation logic
class Booking:
    # Existing methods...

    def apply_penalty(self, host_id):
        # Logic to apply penalty to the host
        print(f"Applying penalty to host: {host_id}")
        self.enforce_penalty(host_id)

    def enforce_penalty(self, host_id):
        # Logic to enforce penalty, such as blocking updates for 30 days
        print(f"Host {host_id} is penalized for 30 days.")
        # Logic to handle repeat offenses
        self.check_repeat_offenses(host_id)

    def check_repeat_offenses(self, host_id):
        # Logic to check for repeat offenses and block host if necessary
        print(f"Checking repeat offenses for host: {host_id}")
        # Placeholder for actual logic to block and erase host details
        self.block_host(host_id)

    def block_host(self, host_id):
        # Logic to block and erase host details
        print(f"Blocking and erasing host details for host: {host_id}")
        # Placeholder for actual blocking and erasing logic
class Booking:
    def __init__(self, booking_id, user_id, host_id, paid, status):
        self.booking_id = booking_id
        self.user_id = user_id
        self.host_id = host_id
        self.paid = paid
        self.status = status

    def cancel_booking(self):
        if not self.is_host_reachable(self.host_id):
            self.process_cancellation()
        else:
            print("Host is reachable. No need to cancel.")

    def is_host_reachable(self, host_id):
        # Logic to check if the host is reachable
        # This could involve checking the host's last activity or sending a ping
        # Placeholder for actual logic
        return self.check_host_activity(host_id)

    def check_host_activity(self, host_id):
        # Detailed logic to check host's last activity
        # For example, checking the last login time or sending a ping
        print(f"Checking activity for host: {host_id}")
        # Placeholder for actual activity check logic
        return False  # Assume host is not reachable for demonstration

    def process_cancellation(self):
        if self.paid:
            self.offer_alternative()
        else:
            self.cancel_unpaid_booking()
        self.apply_penalty(self.host_id)

    def offer_alternative(self):
        alternative_host_id = self.find_alternative_host()
        if alternative_host_id:
            self.update_booking(alternative_host_id)
        else:
            self.process_refund()

    def find_alternative_host(self):
        # Logic to find an alternative host with similar features and location
        # This could involve querying the database for available hosts
        print("Finding alternative host...")
        return "alternative_host_id"  # Placeholder for actual logic

    def update_booking(self, new_host_id):
        self.host_id = new_host_id
        self.status = "Updated"
        print(f"Booking updated to new host: {new_host_id}")

    def process_refund(self):
        # Logic to process refund within 14 business days
        print("Processing refund within 14 business days...")
        self.initiate_refund()

    def initiate_refund(self):
        # Detailed logic to initiate the refund process
        print("Initiating refund process...")
        # Placeholder for actual refund initiation logic

    def cancel_unpaid_booking(self):
        self.status = "Cancelled"
        print("Booking cancelled due to non-payment.")

    def apply_penalty(self, host_id):
        # Logic to apply penalty to the host
        print(f"Applying penalty to host: {host_id}")
        self.enforce_penalty(host_id)

    def enforce_penalty(self, host_id):
        # Logic to enforce penalty, such as blocking updates for 30 days
        print(f"Host {host_id} is penalized for 30 days.")
        # Logic to handle repeat offenses
        self.check_repeat_offenses(host_id)

    def check_repeat_offenses(self, host_id):
        # Logic to check for repeat offenses and block host if necessary
        print(f"Checking repeat offenses for host: {host_id}")
        # Placeholder for actual logic to block and erase host details
        self.block_host(host_id)

    def block_host(self, host_id):
        # Logic to block and erase host details
        print(f"Blocking and erasing host details for host: {host_id}")
        # Placeholder for actual blocking and erasing logic
class Booking:
    # Existing methods...

    def process_refund(self):
        # Logic to process refund within 14 business days
        print("Processing refund within 14 business days...")
        self.initiate_refund()

    def initiate_refund(self):
        # Detailed logic to initiate the refund process
        print("Initiating refund process...")
        # Placeholder for actual refund initiation logic
        # Example: Interacting with payment gateway API to process refund
        self.complete_refund()

    def complete_refund(self):
        # Logic to complete the refund process
        print("Refund completed successfully.")
        # Placeholder for actual refund completion logic
class Booking:
    # Existing methods...

    def apply_penalty(self, host_id):
        # Logic to apply penalty to the host
        print(f"Applying penalty to host: {host_id}")
        self.enforce_penalty(host_id)

    def enforce_penalty(self, host_id):
        # Logic to enforce penalty, such as blocking updates for 30 days
        print(f"Host {host_id} is penalized for 30 days.")
        # Logic to handle repeat offenses
        self.check_repeat_offenses(host_id)

    def check_repeat_offenses(self, host_id):
        # Logic to check for repeat offenses and block host if necessary
        print(f"Checking repeat offenses for host: {host_id}")
        # Placeholder for actual logic to block and erase host details
        self.block_host(host_id)

    def block_host(self, host_id):
        # Logic to block and erase host details
        print(f"Blocking and erasing host details for host: {host_id}")
        # Placeholder for actual blocking and erasing logic
